<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Projects on Sometimes Jeremy Thinks</title>
    <link>https://ackso.net/project/</link>
    <description>Recent content in Projects on Sometimes Jeremy Thinks</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Jeremy T Jackson</copyright>
    <lastBuildDate>Thu, 04 Jan 2018 21:41:19 -0700</lastBuildDate>
    <atom:link href="/project/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Exercises for Programmers 3 - NODEJS</title>
      <link>https://ackso.net/project/exercises-for-programmers-3/</link>
      <pubDate>Thu, 04 Jan 2018 21:41:19 -0700</pubDate>
      
      <guid>https://ackso.net/project/exercises-for-programmers-3/</guid>
      <description>

&lt;p&gt;I&amp;rsquo;m in the midst of working through Chapter 3 of
&lt;a href=&#34;https://pragprog.com/book/bhwb/exercises-for-programmers&#34; target=&#34;_blank&#34;&gt;Exercises for Programmers&lt;/a&gt;
and decided to write an update on my progress because some of these
individual exercises are starting to get a bit long and convoluted,
so I feel like some of them might benefit from being stand-alone posts.
That will certainly be true for Exercise 10, which I finished up last
night, so for this post I&amp;rsquo;m just going to talk about Exercises 7-9.&lt;/p&gt;

&lt;p&gt;Also, &lt;a href=&#34;https://github.com/jeremy-j-ackso/exercises-for-programmers-nodejs&#34; target=&#34;_blank&#34;&gt;here&amp;rsquo;s my Github repo for this project.&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;nav id=&#34;TableOfContents&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#background&#34;&gt;Background&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#exercise-7-area-of-a-rectangular-room&#34;&gt;Exercise 7 - Area of a Rectangular Room&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#exercise-8-pizza-party&#34;&gt;Exercise 8 - Pizza Party&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#exercise-9-paint-calculator&#34;&gt;Exercise 9 - Paint Calculator&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/nav&gt;


&lt;h1 id=&#34;background&#34;&gt;Background&lt;/h1&gt;

&lt;p&gt;This chapter is all about calculations.
All of the exercises have you taking some input, doing some calculations,
and then writing the output.
As you might expect you end up getting cozy with your basic 4 functions,
&lt;code&gt;Math&lt;/code&gt; and &lt;code&gt;Number&lt;/code&gt; methods like rounding and defining decimal precision, and validating
that user inputs are parseable digits.
The complexity that is getting introduced in this chapter also really
forces the issue of making sure that you break out your functionality
into smaller component functions, and you can find some rewarding opportunities
for using arguments to slightly modify your function outputs, for instance
when you&amp;rsquo;re converting between imperial and metric units.&lt;/p&gt;

&lt;p&gt;As you might expect, with more component functions comes more tests.
Like I mentioned, last night I got through Exercise 10, and already my test file
for this chapter is around 750 lines long.
I have three more exercises to go for this chapter, so I&amp;rsquo;m figuring it will grow
to be over 1000 lines before this chapter ends.
That being the case, I&amp;rsquo;m not going to post my tests in here because they&amp;rsquo;re
getting to be rather boilerplate-y and I personally wouldn&amp;rsquo;t be interested in scrolling
for ages through similar-looking mocha tests.
However you can definitely go check the tests out
&lt;a href=&#34;https://github.com/jeremy-j-ackso/exercises-for-programmers-nodejs/blob/master/test/ch3.test.js&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;My scripts that are implementing the &lt;code&gt;readline&lt;/code&gt; functionality for each of the exercises
are also pretty standard for the three exercises here, so I&amp;rsquo;ll just be linking back to
those on Github rather than showing them here.&lt;/p&gt;

&lt;p&gt;The most interesting thing I learned from doing these exercises is that JavaScript
parses &lt;a href=&#34;https://semver.org/&#34; target=&#34;_blank&#34;&gt;semantic versioning numbers&lt;/a&gt; as Floats (or Integers)
of the Major version, the first dot as the decimal point, and the Minor version.
It ignores the second dot and the Patch version.
This means that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;parseFloat(&#39;1.2.3&#39;) // returns 1.2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I had to write tests for this and that also inspired some of my later usage of regular
expressions to validate proper numeric input provided as strings.
That&amp;rsquo;s also something I&amp;rsquo;m going to have to refactor for if I ever go back and do that.
The only reason I discovered this is that when I was writing up my tests I realized
that it should cause the functions to throw an error and I had no idea if it would
or not.&lt;/p&gt;

&lt;p&gt;This was just something that popped into my head and I&amp;rsquo;m glad I wrote that test because
JavaScript is perfectly happy to pretend that these are numbers and will do its
best to accomodate them as such.&lt;/p&gt;

&lt;p&gt;I also tested this in Python and R, and both of them generated errors when attempting
to convert the semver string to some type of numeric, which is what I would have
expected from JavaScript as well.&lt;/p&gt;

&lt;h1 id=&#34;exercise-7-area-of-a-rectangular-room&#34;&gt;Exercise 7 - Area of a Rectangular Room&lt;/h1&gt;

&lt;p&gt;The most fancy thing here is the use of the &lt;code&gt;*=&lt;/code&gt; infix operator to convert
from imperial to metric in the case that the &lt;code&gt;units&lt;/code&gt; required is metric.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/jeremy-j-ackso/exercises-for-programmers-nodejs/blob/master/ch3/area-of-rectangle-room.js&#34; target=&#34;_blank&#34;&gt;Here&amp;rsquo;s the &lt;code&gt;readline&lt;/code&gt; function calling it.&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/* eslint comma-dangle: &amp;quot;off&amp;quot;, comma-spacing: &amp;quot;off&amp;quot; */

function sqft(length, width) {
  const invalids = [null, undefined,]
  if (invalids.includes(length) || invalids.includes(width)) {
    throw new Error(&#39;inputs must not be null or undefined&#39;)
  }

  if (!parseFloat(length) || !parseFloat(width)) {
    throw new Error(&#39;length and width must be digits&#39;)
  }

  return `${areaOfRectangle(length, width, &#39;feet&#39;)} square feet`
}

function sqmeters(length, width) {
  const invalids = [null, undefined,]
  if (invalids.includes(length) || invalids.includes(width)) {
    throw new Error(&#39;inputs must not be null or undefined&#39;)
  }

  if (!parseFloat(length) || !parseFloat(width)) {
    throw new Error(&#39;length and width must be digits&#39;)
  }

  return `${areaOfRectangle(length, width, &#39;meters&#39;)} square meters`
}

function dimensions(length, width) {
  const invalids = [null, undefined,]
  if (invalids.includes(length) || invalids.includes(width)) {
    throw new Error(&#39;inputs must not be null or undefined&#39;)
  }

  if (!parseFloat(length) || !parseFloat(width)) {
    throw new Error(&#39;length and width must be digits&#39;)
  }

  return `You entered dimensions of ${length} feet by ${width} feet.`
}

function areaOfRectangle(length, width, unit) {
  const invalids = [null, undefined,]
  if (invalids.includes(length) || invalids.includes(width) || invalids.includes(unit)) {
    throw new Error(&#39;inputs must not be null or undefined&#39;)
  }

  if (![&#39;feet&#39;, &#39;meters&#39;].includes(unit)) {
    throw new Error(&#39;units must be either \&#39;feet\&#39; or \&#39;meters\&#39;&#39;)
  }

  if (!parseFloat(length) || !parseFloat(width)) {
    throw new Error(&#39;length and width must be digits&#39;)
  }

  let area = length * width
  if (unit === &#39;meters&#39;) area *= 0.09290304
  return area.toFixed(3)
}

module.exports = {
  dimensions,
  sqft,
  sqmeters,
  areaOfRectangle,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;exercise-8-pizza-party&#34;&gt;Exercise 8 - Pizza Party&lt;/h1&gt;

&lt;p&gt;This one has you doing both integer division and grabbing remainders!
I also like that I had to write the &lt;code&gt;pluralizer()&lt;/code&gt; function to correctly
decide what word to use based on the number values.
Also, &lt;code&gt;aboutTheParty()&lt;/code&gt; has some extreme string templating going on.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/jeremy-j-ackso/exercises-for-programmers-nodejs/blob/master/ch3/pizza-party.js&#34; target=&#34;_blank&#34;&gt;Here&amp;rsquo;s the &lt;code&gt;readline&lt;/code&gt; function calling it.&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function remainingPieces(people, pizzas, pieces) {
  if (typeof people !== &#39;string&#39; || typeof pizzas !== &#39;string&#39; || typeof pieces !== &#39;string&#39;) {
    throw new Error(&#39;arguments to this function must be provided as strings&#39;)
  }

  if (!Number.isInteger(parseFloat(people)) ||
    !Number.isInteger(parseFloat(pizzas)) ||
    !Number.isInteger(parseFloat(pieces))) {
    throw new Error(&#39;arguments must be parseable integer digits&#39;)
  }

  const total_pieces = pizzas * pieces
  const pieces_remain = total_pieces % people
  if (pieces_remain === 1) {
    return `There is ${pieces_remain} leftover piece.`
  }
  return `There are ${pieces_remain} leftover pieces.`
}

function piecesPerPerson(people, pizzas, pieces) {
  if (typeof people !== &#39;string&#39; || typeof pizzas !== &#39;string&#39; || typeof pieces !== &#39;string&#39;) {
    throw new Error(&#39;arguments to this function must be provided as strings&#39;)
  }

  if (!Number.isInteger(parseFloat(people)) ||
    !Number.isInteger(parseFloat(pizzas)) ||
    !Number.isInteger(parseFloat(pieces))) {
    throw new Error(&#39;arguments must be parseable integer digits&#39;)
  }

  const total_pieces = pizzas * pieces
  const pieces_each = Math.floor(total_pieces / people)
  return `Each person gets ${pieces_each} pieces of pizza.`
}

function aboutTheParty(people, pizzas, pieces) {
  if (typeof people !== &#39;string&#39; || typeof pizzas !== &#39;string&#39; || typeof pieces !== &#39;string&#39;) {
    throw new Error(&#39;arguments to this function must be provided as strings&#39;)
  }

  if (!Number.isInteger(parseFloat(people)) ||
    !Number.isInteger(parseFloat(pizzas)) ||
    !Number.isInteger(parseFloat(pieces))) {
    throw new Error(&#39;arguments must be parseable integer digits&#39;)
  }

  return `${people} ${pluralizer(&#39;people&#39;, people)} with ${pizzas} ${pluralizer(&#39;pizzas&#39;, pizzas)}, each pizza having ${pieces} ${pluralizer(&#39;pieces&#39;, pieces)}`
}

function pluralizer(type, val) {
  const plurals = {
    people: [&#39;person&#39;, &#39;people&#39;],
    pizzas: [&#39;pizza&#39;, &#39;pizzas&#39;],
    pieces: [&#39;piece&#39;, &#39;pieces&#39;],
  }

  if (!Object.keys(plurals).includes(type)) {
    throw new Error(&#39;type must be one of [\&#39;person\&#39;, \&#39;pizzas\&#39;, \&#39;pieces\&#39;]&#39;)
  }

  if (typeof val !== &#39;string&#39; || !Number.isInteger(parseFloat(val))) {
    throw new Error(&#39;val must be a parseable integer digit supplied as a string&#39;)
  }

  let lookup_val = val - 1
  if (lookup_val &amp;gt; 1) lookup_val = 1
  return plurals[type][lookup_val]
}

module.exports = {
  remainingPieces,
  piecesPerPerson,
  aboutTheParty,
  pluralizer,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;exercise-9-paint-calculator&#34;&gt;Exercise 9 - Paint Calculator&lt;/h1&gt;

&lt;p&gt;This is another &amp;ldquo;area of a rectangle&amp;rdquo; calculator since it&amp;rsquo;s just focused on the
ceiling of a room.
It does impose some nice rounding requirements though.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/jeremy-j-ackso/exercises-for-programmers-nodejs/blob/master/ch3/paintCalc.js&#34; target=&#34;_blank&#34;&gt;Here&amp;rsquo;s the &lt;code&gt;readline&lt;/code&gt; function calling it.&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function paintCalculator(length, width) {
  if (!/^[0-9]+\.?[0-9]*$/.test(length) || typeof length !== &#39;string&#39;) {
    throw new Error(&#39;length must be a parseable number provided as a string&#39;)
  }

  if (!/^[0-9]+\.?[0-9]*$/.test(width) || typeof width !== &#39;string&#39;) {
    throw new Error(&#39;width must be a parseable number provided as a string&#39;)
  }

  const galPerSqFt = 1 / 350
  const sqft_num = dimensions_paint(length, width)

  return Math.ceil(sqft_num * galPerSqFt)
}

function dimensions_paint(length, width) {
  if (!/^[0-9]+\.?[0-9]*$/.test(length) || typeof length !== &#39;string&#39;) {
    throw new Error(&#39;length must be a parseable number provided as a string&#39;)
  }

  if (!/^[0-9]+\.?[0-9]*$/.test(width) || typeof width !== &#39;string&#39;) {
    throw new Error(&#39;width must be a parseable number provided as a string&#39;)
  }

  const length_num = parseFloat(length)
  const width_num = parseFloat(width)
  return length_num * width_num
}

module.exports = {
  paintCalculator,
  dimensions_paint,
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Exercises for Programmers 2 - NODEJS</title>
      <link>https://ackso.net/project/exercises-for-programmers-2/</link>
      <pubDate>Sat, 23 Dec 2017 09:40:33 -0700</pubDate>
      
      <guid>https://ackso.net/project/exercises-for-programmers-2/</guid>
      <description>

&lt;p&gt;It took a couple days (because I was doing them in bed before going to sleep),
but I just finished up Chapter 2 of
&lt;a href=&#34;https://pragprog.com/book/bhwb/exercises-for-programmers&#34; target=&#34;_blank&#34;&gt;Exercises for Programmers&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;nav id=&#34;TableOfContents&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#background-and-thinking&#34;&gt;Background and Thinking&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#package-json&#34;&gt;&lt;code&gt;package.json&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#tests&#34;&gt;Tests&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#exercise-1&#34;&gt;Exercise 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#exercise-2&#34;&gt;Exercise 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#exercise-3&#34;&gt;Exercise 3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#exercise-4&#34;&gt;Exercise 4&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#exercise-5&#34;&gt;Exercise 5&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#exercise-6&#34;&gt;Exercise 6&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/nav&gt;


&lt;h1 id=&#34;background-and-thinking&#34;&gt;Background and Thinking&lt;/h1&gt;

&lt;p&gt;This chapter is where you actually start in on working on the advertised &amp;ldquo;57 exercises&amp;rdquo;.
It really does want you to be able to run these exercises as stand-alone command-line
programs (and challenges you to also implement in them in various ways, such as with a GUI),
so I decided to yield and get in on Node&amp;rsquo;s &lt;code&gt;readline&lt;/code&gt; package.
&lt;code&gt;readline&lt;/code&gt; is stream-based, so you have a couple of options in how you get it working.
I opted for the callback-style rather than using &lt;code&gt;pipe&lt;/code&gt;, but if I ever go back and refactor
this stuff I&amp;rsquo;ll be implementing &lt;code&gt;pipe&lt;/code&gt; so that the code can be cleaner.&lt;/p&gt;

&lt;p&gt;In order to make testing easier I broke each exercise down into two pieces: a function that
takes the inputs and produces the desired outputs, and a script that implements &lt;code&gt;readlines&lt;/code&gt;
to ask the user questions, calls the aforementioned function, and then &lt;code&gt;console.log()&lt;/code&gt;s the
output.&lt;/p&gt;

&lt;p&gt;I also made a single test file for the whole chapter to keep all these exercises together.
I&amp;rsquo;m still only testing the functions themselves, but I&amp;rsquo;m investigating methods for testing
the &lt;code&gt;readline&lt;/code&gt; scripts as well so that I can also test the interactions between the functions
and their calling scripts.
So far I&amp;rsquo;ve only found a couple of blog posts that explain how to do it, but the methods
being implemented seem to all be pretty verbose and require some finnagling and/or refactoring
the &lt;code&gt;readline&lt;/code&gt; into a &lt;code&gt;Promise&lt;/code&gt;.
I&amp;rsquo;ll probably look into how different packages that provide cli interactivity do this, like
&lt;code&gt;eslint&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;While reading up on &lt;code&gt;readline&lt;/code&gt; I also found out about &lt;code&gt;npm link&lt;/code&gt;, and I&amp;rsquo;m really excited for it.
&lt;code&gt;npm link&lt;/code&gt; looks for the &lt;code&gt;bin&lt;/code&gt; object in your &lt;code&gt;package.json&lt;/code&gt; and then creates a symlink from
&lt;code&gt;/usr/bin/&amp;lt;key&amp;gt;&lt;/code&gt; to &lt;code&gt;~/mydir/&amp;lt;value&amp;gt;.js&lt;/code&gt;.
That way you can have your Node scripts run as if they were actual command line programs
that can be called by name rather than by running &lt;code&gt;node &amp;lt;file&amp;gt;.js --arguments ...&lt;/code&gt;.
One thing to keep in mind is that &lt;code&gt;npm link&lt;/code&gt; may break your legitimate functions in &lt;code&gt;/usr/bin&lt;/code&gt;
by creating that symlink.
To avoid that, I added &lt;code&gt;-js&lt;/code&gt; to the end of each of my keys in the &lt;code&gt;bin&lt;/code&gt; object so that it
would never conflict with or break things.
This was the thing I was definitely most excited about learning during this whole chapter.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/jeremy-j-ackso/exercises-for-programmers-nodejs&#34; target=&#34;_blank&#34;&gt;My repo&lt;/a&gt; for this
continues to grow. I think I&amp;rsquo;m going to skip branching on this until I start going back for
refactors.&lt;/p&gt;

&lt;h1 id=&#34;package-json&#34;&gt;&lt;code&gt;package.json&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;I&amp;rsquo;m just going to drop in my &lt;code&gt;bin&lt;/code&gt; object to keep things short(er).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&amp;quot;bin&amp;quot;: {
  &amp;quot;hello-js&amp;quot;: &amp;quot;./ch2/hello.js&amp;quot;,
  &amp;quot;countChars-js&amp;quot;: &amp;quot;./ch2/countChars.js&amp;quot;,
  &amp;quot;quote-js&amp;quot;: &amp;quot;./ch2/quote.js&amp;quot;,
  &amp;quot;madlib-js&amp;quot;: &amp;quot;./ch2/madlib.js&amp;quot;,
  &amp;quot;simplemath-js&amp;quot;: &amp;quot;./ch2/simplemath.js&amp;quot;,
  &amp;quot;retirement-js&amp;quot;: &amp;quot;./ch2/retirement.js&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;tests&#34;&gt;Tests&lt;/h1&gt;

&lt;p&gt;As I mentioned, I dropped everything from this chapter into a single test file so that they
would be grouped together in my mocha output.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/* eslint no-undef: &amp;quot;off&amp;quot;, no-sparse-arrays: &amp;quot;off&amp;quot;, comma-spacing: &amp;quot;off&amp;quot;, comma-dangle: &amp;quot;off&amp;quot; */

const expect = require(&#39;expect.js&#39;)

const hellof = require(&#39;../ch2/ex1.js&#39;)
const countChars = require(&#39;../ch2/ex2.js&#39;)
const quote = require(&#39;../ch2/ex3.js&#39;)
const madlib = require(&#39;../ch2/ex4.js&#39;)
const simplemath = require(&#39;../ch2/ex5.js&#39;)
const retirement = require(&#39;../ch2/ex6.js&#39;)

describe(&#39;ch2&#39;, () =&amp;gt; {
  describe(&#39;ex1.js&#39;, () =&amp;gt; {
    it(&#39;should return values equal to reference.&#39;, () =&amp;gt; {
      const ref_test = [
        { args: &#39;Jeremy&#39;, expect: &#39;Hello, Jeremy, nice to meet you!&#39; },
        { args: &#39;Sue&#39;, expect: &#39;Hello, Sue, nice to meet you!&#39; },
        { args: &#39;Bob&#39;, expect: &#39;Hello, Bob, nice to meet you!&#39; },
        { args: &#39;Ana&#39;, expect: &#39;Hello, Ana, nice to meet you!&#39; },
        { args: &#39;Tom&#39;, expect: &#39;Hello, Tom, nice to meet you!&#39; },
        { args: &#39;5&#39;, expect: &#39;Hello, 5, nice to meet you!&#39; },
      ]
      ref_test.forEach((test) =&amp;gt; {
        expect(hellof(test.args)).to.eql(test.expect)
      })
    })

    it(&#39;should throw an error if not given a string&#39;, () =&amp;gt; {
      const err_test = [
        { args: undefined },
        { args: null },
        { args: 5 },
      ]
      err_test.forEach((test) =&amp;gt; {
        expect(hellof).withArgs(test.args).to.throwError(&#39;name should be a string&#39;)
      })
    })
  })

  describe(&#39;ex2.js&#39;, () =&amp;gt; {
    it(&#39;should return values equal to reference&#39;, () =&amp;gt; {
      const ref_test = [
        { args: &#39;Jeremy&#39;, expect: 6 },
        { args: &#39;bob&#39;, expect: 3 },
        { args: &#39;eleventy-one&#39;, expect: 12 },
      ]
      ref_test.forEach((test) =&amp;gt; {
        expect(countChars(test.args)).to.equal(test.expect)
      })
    })

    it(&#39;should throw an error if not given a string&#39;, () =&amp;gt; {
      const err_test = [
        { args: undefined },
        { args: null },
        { args: 5 },
      ]
      err_test.forEach((test) =&amp;gt; {
        expect(countChars).withArgs(test.args).to.throwError(&#39;inputString should be a string&#39;)
      })
    })
  })

  describe(&#39;ex3.js&#39;, () =&amp;gt; {
    it(&#39;should return values equal to reference&#39;, () =&amp;gt; {
      const ref_test = [
        { args: [&#39;bob&#39;, &#39;Hi.&#39;], expect: &#39;bob says, &amp;quot;Hi.&amp;quot;&#39; },
        { args: [&#39;Joe&#39;, &#39;Hello.&#39;], expect: &#39;Joe says, &amp;quot;Hello.&amp;quot;&#39; },
        { args: [&#39;R2D2&#39;, &#39;beep-bloop&#39;], expect: &#39;R2D2 says, &amp;quot;beep-bloop&amp;quot;&#39; },
      ]
      ref_test.forEach((test) =&amp;gt; {
        expect(quote(test.args[0], test.args[1])).to.equal(test.expect)
      })
    })

    it(&#39;should throw an error if an argument is empty, undefined, or null&#39;, () =&amp;gt; {
      const err_test = [
        { args: [,] },
        { args: [, &#39;hi&#39;] },
        { args: [&#39;hi&#39;,] },
        { args: [null, null] },
        { args: [null, &#39;hi&#39;] },
        { args: [&#39;hi&#39;, null] },
        { args: [undefined, undefined] },
        { args: [undefined, &#39;hi&#39;] },
        { args: [&#39;hi&#39;, undefined] },
      ]
      err_test.forEach((test) =&amp;gt; {
        expect(quote).withArgs(test.args[0], test.args[1]).to.throwError(&#39;all arguments must be strings&#39;)
      })
    })

    it(&#39;should throw an error if an argument is not a string&#39;, () =&amp;gt; {
      const err_test = [
        { args: [1, &#39;hi&#39;] },
        { args: [&#39;hi&#39;, 1] },
        { args: [1, 1] },
      ]
      err_test.forEach((test) =&amp;gt; {
        expect(quote).withArgs(test.args[0], test.args[1]).to.throwError(&#39;all arguments must be strings&#39;)
      })
    })
  })

  describe(&#39;ex4.js&#39;, () =&amp;gt; {
    it(&#39;should return values equal to reference&#39;, () =&amp;gt; {
      const ref_test = [
        { args: [&#39;dog&#39;, &#39;walk&#39;, &#39;blue&#39;, &#39;quickly&#39;], expect: &#39;Do you walk your blue dog quickly? That\&#39;s hilarious!&#39; },
        { args: [&#39;cat&#39;, &#39;jump&#39;, &#39;lithe&#39;, &#39;anxiously&#39;], expect: &#39;Do you jump your lithe cat anxiously? That\&#39;s hilarious!&#39; },
        { args: [&#39;noun&#39;, &#39;verb&#39;, &#39;adjective&#39;, &#39;adverb&#39;], expect: &#39;Do you verb your adjective noun adverb? That\&#39;s hilarious!&#39; },
      ]
      ref_test.forEach((test) =&amp;gt; {
        expect(madlib(test.args[0], test.args[1], test.args[2], test.args[3])).to.equal(test.expect)
      })
    })

    it(&#39;should throw an error if an argument is empty, undefined, or null&#39;, () =&amp;gt; {
      const err_test = [
        { args: [,,,] },
        { args: [, &#39;hi&#39;,,] },
        { args: [&#39;hi&#39;,,,] },
        { args: [null, null, null, null] },
        { args: [null, &#39;hi&#39;, null, null] },
        { args: [&#39;hi&#39;, null, null, null] },
        { args: [undefined, undefined, undefined, undefined] },
        { args: [undefined, &#39;hi&#39;, undefined, undefined] },
        { args: [&#39;hi&#39;, undefined, undefined, undefined] },
      ]
      err_test.forEach((test) =&amp;gt; {
        expect(madlib).withArgs(test.args[0], test.args[1], test.args[2], test.args[3]).to.throwError(&#39;all arguments must be strings&#39;)
      })
    })

    it(&#39;should throw an error if an argument is not a string&#39;, () =&amp;gt; {
      const err_test = [
        { args: [1, &#39;hi&#39;, &#39;hi&#39;, &#39;hi&#39;] },
        { args: [&#39;hi&#39;, 1, &#39;hi&#39;, &#39;hi&#39;] },
        { args: [1, 1, 1, 1] },
      ]
      err_test.forEach((test) =&amp;gt; {
        expect(madlib).withArgs(test.args[0], test.args[1]).to.throwError(&#39;all arguments must be strings&#39;)
      })
    })
  })

  describe(&#39;ex5.js&#39;, () =&amp;gt; {
    it(&#39;should return values equal to reference&#39;, () =&amp;gt; {
      const ref_test = [
        { args: [&#39;1&#39;, &#39;2&#39;], expect: &#39;1 + 2 = 3\n1 - 2 = -1\n1 * 2 = 2\n1 / 2 = 0.5&#39; },
        { args: [&#39;8&#39;, &#39;3&#39;], expect: &#39;8 + 3 = 11\n8 - 3 = 5\n8 * 3 = 24\n8 / 3 = 2.67&#39; },
        { args: [&#39;19&#39;, &#39;1&#39;], expect: &#39;19 + 1 = 20\n19 - 1 = 18\n19 * 1 = 19\n19 / 1 = 19&#39; },
      ]
      ref_test.forEach((test) =&amp;gt; {
        expect(simplemath(test.args[0], test.args[1])).to.equal(test.expect)
      })
    })

    it(&#39;should throw an error if the string input cannot be coerced to a number&#39;, () =&amp;gt; {
      const err_test = [
        { args: [&#39;one&#39;, &#39;1&#39;] },
        { args: [&#39;1&#39;, &#39;one&#39;] },
        { args: [&#39;one&#39;, &#39;one&#39;] },
      ]
      err_test.forEach((test) =&amp;gt; {
        expect(simplemath).withArgs(test.args[0], test.args[1]).to.throwError(&#39;inputs must be digits&#39;)
      })
    })

    it(&#39;should throw an error if the input is actually a number and not a string&#39;, () =&amp;gt; {
      const err_test = [
        { args: [1, 1] },
        { args: [&#39;one&#39;, 1] },
        { args: [1, &#39;one&#39;] },
      ]
      err_test.forEach((test) =&amp;gt; {
        expect(simplemath).withArgs(test.args[0], test.args[1]).to.throwError(&#39;inputs must be digits&#39;)
      })
    })

    it(&#39;should throw an error if inputs are null or undefined&#39;, () =&amp;gt; {
      const err_test = [
        { args: [,] },
        { args: [undefined,] },
        { args: [, undefined] },
        { args: [undefined, undefined] },
        { args: [null,] },
        { args: [, null] },
        { args: [null, null] },
      ]
      err_test.forEach((test) =&amp;gt; {
        expect(simplemath).withArgs(test.args[0], test.args[1]).to.throwError(&#39;inputs must be digits&#39;)
      })
    })
  })

  describe(&#39;ex6.js&#39;, () =&amp;gt; {
    it(&#39;should return values equal to reference&#39;, () =&amp;gt; {
      const ref_test = [
        { args: [&#39;20&#39;, &#39;40&#39;], expect: &#39;You have 20 years left until you can retire.\nIt\&#39;s 2017, so you can retire in 2037.&#39; },
        { args: [&#39;20&#39;, &#39;60&#39;], expect: &#39;You have 40 years left until you can retire.\nIt\&#39;s 2017, so you can retire in 2057.&#39; },
      ]
      ref_test.forEach((test) =&amp;gt; {
        expect(retirement(test.args[0], test.args[1])).to.equal(test.expect)
      })
    })

    it(&#39;should throw an error if the input is actually a number and not a string&#39;, () =&amp;gt; {
      const err_test = [
        { args: [1, 1] },
        { args: [&#39;one&#39;, 1] },
        { args: [1, &#39;one&#39;] },
      ]
      err_test.forEach((test) =&amp;gt; {
        expect(simplemath).withArgs(test.args[0], test.args[1]).to.throwError(&#39;inputs must be digits&#39;)
      })
    })

    it(&#39;should throw an error if inputs are null or undefined&#39;, () =&amp;gt; {
      const err_test = [
        { args: [,] },
        { args: [undefined,] },
        { args: [, undefined] },
        { args: [undefined, undefined] },
        { args: [null,] },
        { args: [, null] },
        { args: [null, null] },
      ]
      err_test.forEach((test) =&amp;gt; {
        expect(simplemath).withArgs(test.args[0], test.args[1]).to.throwError(&#39;inputs must be digits&#39;)
      })
    })
  })
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;exercise-1&#34;&gt;Exercise 1&lt;/h1&gt;

&lt;p&gt;Exercise 1 was just a simple &amp;ldquo;Hello Bob!&amp;rdquo; kind of thing.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s &lt;code&gt;ex1.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function hello(name) {
  if (typeof name !== &#39;string&#39;) throw new Error(&#39;name should be a string&#39;)
  return `Hello, ${name}, nice to meet you!`
}

module.exports = hello
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s it&amp;rsquo;s calling script, &lt;code&gt;hello.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;#!/usr/bin/node

const readline = require(&#39;readline&#39;)
const hellof = require(&#39;./ex1.js&#39;)

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
})

rl.question(&#39;What is your name? &#39;, (name) =&amp;gt; {
  const response = hellof(name)
  console.log(response)
  rl.close()
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;exercise-2&#34;&gt;Exercise 2&lt;/h1&gt;

&lt;p&gt;Exercise 2 outputs the number of characters in a string.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s &lt;code&gt;ex2.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function countChars(inputString) {
  if (typeof inputString !== &#39;string&#39;) throw new Error(&#39;inputString should be a string&#39;)
  const chars = inputString.length
  return chars
}

module.exports = countChars
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s it&amp;rsquo;s calling script, &lt;code&gt;countChars.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;#!/usr/bin/node

const readline = require(&#39;readline&#39;)
const countChars = require(&#39;./ex2.js&#39;)

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
})

rl.question(&#39;What is the input string? &#39;, (inputString) =&amp;gt; {
  const response = countChars(inputString)
  console.log(`${inputString}: ${response}`)
  rl.close()
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;exercise-3&#34;&gt;Exercise 3&lt;/h1&gt;

&lt;p&gt;This exercise asks two questions, which is where taking advantage of &lt;code&gt;pipe&lt;/code&gt; with these
streams starts to show its usefulness. You give it a quote and who said it, and
it puts them together in a single string.&lt;/p&gt;

&lt;p&gt;Here &lt;code&gt;ex3.js&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/* eslint prefer-template: &amp;quot;off&amp;quot; */

// prefer-template is switched off because the book says to use concatenation.

function quote(author, qte) {
  if (typeof author !== &#39;string&#39;) throw new Error(&#39;all arguments must be strings&#39;)
  if (typeof qte !== &#39;string&#39;) throw new Error(&#39;all arguments must be strings&#39;)
  return author + &#39; says, &amp;quot;&#39; + qte + &#39;&amp;quot;&#39;
}

module.exports = quote
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s its calling script, &lt;code&gt;quote.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;#!/usr/bin/node

const readline = require(&#39;readline&#39;)
const quote = require(&#39;./ex3.js&#39;)

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
})

rl.question(&#39;What is the quote? &#39;, (inputQuote) =&amp;gt; {
  rl.question(&#39;Who said it? &#39;, (inputSpeaker) =&amp;gt; {
    const response = quote(inputSpeaker, inputQuote)
    console.log(response)
    rl.close()
  })
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;exercise-4&#34;&gt;Exercise 4&lt;/h1&gt;

&lt;p&gt;This exercise does a basic madlibs-style of string creation. With 4 inputs, I&amp;rsquo;m definitely
seeing callback hell start to creep into the &lt;code&gt;readline&lt;/code&gt; block.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s &lt;code&gt;ex4.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function madlib(noun, verb, adjective, adverb) {
  if (typeof noun !== &#39;string&#39; || typeof verb !== &#39;string&#39; ||
    typeof adjective !== &#39;string&#39; || typeof adverb !== &#39;string&#39;) {
    throw new Error(&#39;all arguments must be strings&#39;)
  }
  return `Do you ${verb} your ${adjective} ${noun} ${adverb}? That&#39;s hilarious!`
}

module.exports = madlib
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s its calling script &lt;code&gt;madlib.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;#!/usr/bin/node

const readline = require(&#39;readline&#39;)
const madlib = require(&#39;../ch2/ex4.js&#39;)


const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
})

let builder = {}
rl.question(&#39;Enter a noun: &#39;, (noun) =&amp;gt; {
  builder.noun = noun
  rl.question(&#39;Enter a verb: &#39;, (verb) =&amp;gt; {
    builder.verb = verb
    rl.question(&#39;Enter an adjective: &#39;, (adjective) =&amp;gt; {
      builder.adjective = adjective
      rl.question(&#39;Enter an adverb: &#39;, (adverb) =&amp;gt; {
        builder.adverb = adverb
        console.log(madlib(builder.noun, builder.verb, builder.adjective, builder.adverb))
        rl.close()
      })
    })
  })
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;exercise-5&#34;&gt;Exercise 5&lt;/h1&gt;

&lt;p&gt;This one does the basic four arithmetic functions on two input numbers.
I can probably refactor how I&amp;rsquo;m producing the output string to be a bit more elegant and shorter
(I&amp;rsquo;m thinking string concatenation with array destructuring), but this is fine for a
first stab at it.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s &lt;code&gt;ex5.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/* eslint no-restricted-globals: &amp;quot;off&amp;quot; */

function simplemath(firstNum, secondNum) {
  if (isNaN(Number(firstNum))) throw new Error(&#39;inputs must be digits&#39;)
  if (isNaN(Number(secondNum))) throw new Error(&#39;inputs must be digits&#39;)

  if (typeof firstNum !== &#39;string&#39;) throw new Error(&#39;inputs must be digits&#39;)
  if (typeof secondNum !== &#39;string&#39;) throw new Error(&#39;inputs must be digits&#39;)

  const fnum = Number(firstNum)
  const snum = Number(secondNum)

  let mathObj = {
    add: fnum + snum,
    subtract: fnum - snum,
    multiply: fnum * snum,
    divide: fnum / snum,
  }

  mathObj.divide = parseFloat(mathObj.divide.toFixed(2))

  return `${fnum} + ${snum} = ${mathObj.add}\n${fnum} - ${snum} = ${mathObj.subtract}\n${fnum} * ${snum} = ${mathObj.multiply}\n${fnum} / ${snum} = ${mathObj.divide}`
}

module.exports = simplemath
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s its calling script &lt;code&gt;simplemath.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;#!/usr/bin/node

const readline = require(&#39;readline&#39;)
const simplemath = require(&#39;./ex5.js&#39;)

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
})

let values = {}
rl.question(&#39;What is the first number? &#39;, (firstNumber) =&amp;gt; {
  values.firstNumber = firstNumber
  rl.question(&#39;What is the second number? &#39;, (secondNumber) =&amp;gt; {
    values.secondNumber = secondNumber
    console.log(simplemath(values.firstNumber, values.secondNumber))
    rl.close()
  })
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;exercise-6&#34;&gt;Exercise 6&lt;/h1&gt;

&lt;p&gt;This exercise starts incorporating &lt;code&gt;Date()&lt;/code&gt; and doing math with that. Other than that, it&amp;rsquo;s
pretty much the same as the others.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s &lt;code&gt;ex6.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/* eslint no-restricted-globals: &amp;quot;off&amp;quot; */

function retirement(currentAge, retirementAge) {
  if (isNaN(Number(currentAge))) throw new Error(&#39;inputs must be digits&#39;)
  if (isNaN(Number(retirementAge))) throw new Error(&#39;inputs must be digits&#39;)

  if (typeof currentAge !== &#39;string&#39;) throw new Error(&#39;inputs must be digits&#39;)
  if (typeof retirementAge !== &#39;string&#39;) throw new Error(&#39;inputs must be digits&#39;)

  const years = retirementAge - currentAge
  const curYear = new Date().getFullYear()
  const retYear = curYear + years
  return `You have ${years} years left until you can retire.\nIt&#39;s ${curYear}, so you can retire in ${retYear}.`
}

module.exports = retirement
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s its calling script, &lt;code&gt;retirement.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;#!/usr/bin/node

const readline = require(&#39;readline&#39;)
const retirement = require(&#39;./ex6.js&#39;)

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
})

let values = {}
rl.question(&#39;What is your current age? &#39;, (firstNumber) =&amp;gt; {
  values.firstNumber = firstNumber
  rl.question(&#39;At what age would you like to retire? &#39;, (secondNumber) =&amp;gt; {
    values.secondNumber = secondNumber
    console.log(retirement(values.firstNumber, values.secondNumber))
    rl.close()
  })
})
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Exercises for Programmers 1 - NodeJS</title>
      <link>https://ackso.net/project/exercises-for-programmers-1/</link>
      <pubDate>Tue, 19 Dec 2017 21:07:16 -0700</pubDate>
      
      <guid>https://ackso.net/project/exercises-for-programmers-1/</guid>
      <description>

&lt;p&gt;I decided to start working through exercises in
&lt;a href=&#34;https://pragprog.com/book/bhwb/exercises-for-programmers&#34; target=&#34;_blank&#34;&gt;Exercises for Programmers&lt;/a&gt;
and sticking my solutions and thoughts here.
I definitely encourage you to buy directly from &lt;a href=&#34;https://pragprog.com&#34; target=&#34;_blank&#34;&gt;The Pragmatic Bookshelf&lt;/a&gt;.
I really love their books because they have great depth and they often cover a lot
of things that are of interest and value to the technical community, but aren&amp;rsquo;t
just about tech.
A great example of this is
&lt;a href=&#34;https://pragprog.com/book/ahptl/pragmatic-thinking-and-learning&#34; target=&#34;_blank&#34;&gt;Pragmatic Thinking and Learning&lt;/a&gt;
which I&amp;rsquo;ve gotten a great deal of value from.&lt;/p&gt;

&lt;p&gt;Anyhow, on with the first exercise in the book!&lt;/p&gt;

&lt;h1 id=&#34;chapter-1&#34;&gt;Chapter 1&lt;/h1&gt;

&lt;p&gt;The Chapter 1 exercise to kick things off is for creating a tip calculator.
The book wants it to be an interactive program, using &lt;code&gt;readlines&lt;/code&gt;-type functionality.
I&amp;rsquo;m opting (for now at least) to just write functions that take the parameters as defined
in the problem, and outputting an object or something that can be fairly easily parsed.
This lets me easily test it.&lt;/p&gt;

&lt;h2 id=&#34;testing&#34;&gt;Testing&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;m using &lt;a href=&#34;https://mochajs.org&#34; target=&#34;_blank&#34;&gt;Mocha&lt;/a&gt; with &lt;a href=&#34;https://github.com/Automattic/expect.js&#34; target=&#34;_blank&#34;&gt;Expect.js&lt;/a&gt;
for my testing.
I started out with just a couple simple tests to verify that the outputs from known inputs
matched some reference values and used that as my only test until things started working.
From there I started adding in other test conditions, like what should happen if strings or
&lt;code&gt;undefined&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; values are enterred, and added conditionals in my function to check
for and handle these scenarios.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s my &lt;code&gt;ch1.test.js&lt;/code&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/* eslint no-undef: &amp;quot;off&amp;quot; */

let expect = require(&#39;expect.js&#39;)
let tipCalculator = require(&#39;../ch1&#39;)

describe(&#39;tipCalculator&#39;, () =&amp;gt; {
  let ref_tests = [
    { args: [1, 15], expected: { tip: 0.15, total: 1.15 } },
    { args: [15, 20], expected: { tip: 3.00, total: 18.00 } },
    { args: [15.30, 18.5], expected: { tip: 2.83, total: 18.13 } },
  ]
  it(&#39;correctly outputs values equal to reference&#39;, () =&amp;gt; {
    ref_tests.forEach((test) =&amp;gt; {
      expect(tipCalculator(test.args[0], test.args[1])).to.eql(test.expected)
    })
  })

  let err_tests = [
    { args: [&#39;one&#39;, 15], throws: &#39;billAmount must be a number, either float or integer.&#39; },
    { args: [1, &#39;fifteen&#39;], throws: &#39;tipRate must be a number, either float or integer.&#39; },
    { args: [&#39;one&#39;, &#39;fifteen&#39;], throws: &#39;billAmount must be a number, either float or integer.&#39; },
    { args: [0, 15], throws: &#39;billAmount must be greater than 0&#39; },
    { args: [-12, 15], throws: &#39;billAmount must be greater than 0&#39; },
    { args: [12, -15], throws: &#39;tipRate must be greater than 0&#39; },
    { args: [12, 0], throws: &#39;tipRate must be greater than 0&#39; },
    { args: [undefined, 0], throws: &#39;billAmount must be greater than 0&#39; },
    { args: [0, undefined], throws: &#39;tipRate must be greater than 0&#39; },
    { args: [undefined, undefined], throws: &#39;billAmount must be greater than 0&#39; },
    { args: [null, null], throws: &#39;billAmount must be greater than 0&#39; },
  ]
  it(&#39;throw on invalid inputs&#39;, () =&amp;gt; {
    err_tests.forEach((test) =&amp;gt; {
      expect(tipCalculator).withArgs(test.args[0], test.args[1]).to.throwError(test.throws)
    })
  })
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;tipcalculator-function&#34;&gt;&lt;code&gt;tipCalculator&lt;/code&gt; Function&lt;/h2&gt;

&lt;p&gt;My &lt;code&gt;tipCalculator&lt;/code&gt; function started out just doing the basic math required to calculate the
tip amount and the total bill amount based on the two inputs.
As it started passing the test showing that it was equal to reference and I added more tests
for bad inputs, it necessarily grew in order to handle those things.
Basically, none of that progression should come as a surprise.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the function in all its glory:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function tipCalculator(billAmount, tipRate) {
  let bill = billAmount
  let tipPerc = tipRate

  if (typeof bill !== &#39;number&#39;) {
    throw new Error(&#39;billAmount must be a number, either float or integer.&#39;)
  }

  if (typeof tipPerc !== &#39;number&#39;) {
    throw new Error(&#39;tipRate must be a number, either float or integer.&#39;)
  }

  if (bill &amp;lt;= 0) {
    throw new Error(&#39;billAmount must be greater than 0&#39;)
  }

  if (tipPerc &amp;lt;= 0) {
    throw new Error(&#39;tipRate must be greater than 0&#39;)
  }

  if (tipPerc &amp;lt; 1) {
    console.warn(
      &#39;You entered a tipRate less than 1.\n&#39;,
      &#39;The program will still function with this value, however you should know that it &#39;,
      &#39;expects the tipRate to be in the form of, for example 15%, so you would enter 15 &#39;,
      &#39;not 0.15.\n&#39;,
    )
  }

  tipPerc /= 100

  let tip = parseFloat((bill * tipPerc).toFixed(2))
  let total = parseFloat((bill + tip).toFixed(2))

  return { tip, total }
}

module.exports = tipCalculator
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;growing&#34;&gt;Growing&lt;/h2&gt;

&lt;p&gt;After I was mostly finished I started reviewing my work and the documentation for Mocha and
realized that I could set Mocha to watch for changes in my files, which is super handy.
After adding that into my &lt;code&gt;package.json&lt;/code&gt; I also realized that I hadn&amp;rsquo;t seen a single &lt;code&gt;eslint&lt;/code&gt;
message the whole time that I was writing it and realized I had failed to initialize it.
So I got that initialized along with some of my favored &lt;code&gt;eslint&lt;/code&gt; settings and set about to
correcting my linting errors until I made it to what I&amp;rsquo;ve posted here.&lt;/p&gt;

&lt;h1 id=&#34;aftermath&#34;&gt;Aftermath&lt;/h1&gt;

&lt;p&gt;So this was good.
It&amp;rsquo;s been a bit since I&amp;rsquo;ve set up a Node project from scratch, and I&amp;rsquo;m going to keep working
through these exercises and posting on my progress here.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m looking forward to working through Chapter 2.
It has 6 pretty basic exercises, so we&amp;rsquo;ll see if I can get them all into one post, or if it
will take a few to get through.&lt;/p&gt;

&lt;p&gt;Also, you can check out my repo of all of my code for this series of posts
&lt;a href=&#34;https://github.com/jeremy-j-ackso/exercises-for-programmers-nodejs&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
